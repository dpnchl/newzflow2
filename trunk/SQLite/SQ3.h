#pragma once

#include "sqlite3.h" // sqlite3 API

/***********************************************************
The sq3 namespace encapsulates an OO sqlite3 API for
navigating.de projects.

The classes in this namespace were written by stephan beal
<stephan@s11n.net>. They are modelled heavily off of public domain
STL-based code by Cory Nelson:

http://dev.int64.org/sqlite.html

but have been reimplemented from scratch to use the MFC
CString class instead of std::string, use the Unicode-based
API throughout, to conform to MFC naming conventions, and
to work under WindowsCE platforms.

This code assumes that UNICODE support is enabled. If it
is not then this code will certainly fail in
catastrophic ways (if it compiles at all).

Lots of high-quality documentation about using sqlite3 can be
found at the sqlite website: http://sqlite.org.

This code, like sqlite3 itself, is released into the
Public Domain.

Design notes:

These classes *should* use exceptions to report errors,
but i'm building for WinCE here and i constantly get
warnings from eVC that stack unwinding isn't enabled
(which presumably means that exceptions can't properly work).
i FINALLY found an "oh, by the way" message in the
CException::Delete() docs which says:

"You only need to call Delete if you are using the C++
try-catch mechanism, which is not supported for Window CE."

Later reading revealed that exceptions are only enabled on CE
if the CE kernel is compiled with specific options.

Fuck. So this code is a lot more C-ish and a lot less C++-ish
than i would like.
***********************************************************/

namespace sq3 {
	typedef __int64 int64_t;

	/**
	Database is a wrapper around an sqlite3 database. It provides
	the basic open/close functionality, as well as convenience
	functions for running simple queries. For more advanced queries
	you can use the Statement and Reader classes.

	*/
	class Database  
	{
	public:
		/**
		Calls this->Open() to open a database.
		The db is created if it does not currently
		exist. Use this->IsOpen() to find out if
		the opening succeeded.

		Note that sqlite3 supports a special name,
		":memory:", which creates an in-memory database
		with no associated file.
		*/
		explicit Database( CString const & dbname );
		Database();

		/**
		Closes the db and frees resources associated with it.
		*/
		~Database();

		/**
		Closes the db handle. No db-level operations are possible
		on this object after close is called, and using such
		operations on a closed db provides undefined results.

		The return value is that of sqlite3_close().

		Closing a closed db is a no-op, and causes 0 to be returned.
		*/
		int Close();

		/**
		Opens the underlying database. The return value is that
		of sqlite3_open16().
		*/
		int Open( CString const & name );

		/**
		Returns true if this db was successfully opened, else false.
		*/
		bool IsOpen() const;

		/**
		Returns the name of the database, as passed to Open()
		or the constructor.
		*/
		CString GetName() const;

		/**
		Returns the low-level DB handle. DO NOT use sqlite3_close()
		on this object. The returned value will be 0 after
		Close() is called.
		*/
		sqlite3 * GetHandle() const;

		/**
		Returns the last error message associated with this object.
		Stupidly, sqlite3 returns the literal string "not an error"
		when there is no error, instead of returning an empty string.
		*/
		CString GetErrorMessage() const;

		/**
		Returns the most recent insert ID generated by
		an insert statement.
		*/
		int64_t GetLastInsertID() const;

		/**
		Sets the "busy timeout", in milliseconds.
		See sqlite3_busy_timeout() for more details.
		*/
		void SetBusyTimeout( int millis );

		int Execute( char const * sql);

		/**
		Executes the given sql and sets val to the value of the first column of data
		from the first row of the result. It returns the result of the underlying
		sqlite3_exec() call (SQLITE_OK == success). If the query fails, val is unmodifed.
		*/
		int ExecuteInt( CString const & sql, int & val );

		/**
		Executes the given sql and sets val to the value of the first column of data
		from the first row of the result. It returns the result of the underlying
		sqlite3_exec() call (SQLITE_OK == success). If the query fails, val is unmodifed.
		*/
		int ExecuteInt64( CString const & sql, int64_t & val );

		/**
		Executes the given sql and sets val to the value of the first column of data
		from the first row of the result. It returns the result of the underlying
		sqlite3_exec() call (SQLITE_OK == success). If the query fails, val is unmodifed.
		*/
		int ExecuteDouble( CString const & sql, double & val );

		/**
		Executes the given sql and sets val to the value of the first column of data
		from the first row of the result. It returns the result of the underlying
		sqlite3_exec() call (SQLITE_OK == success). If the query fails, val is unmodifed.
		*/
		int ExecuteString( CString const & sql, CString & val );

		/**
		Executes the given sql and sets val to the value of the first column of data
		from the first row of the result. If the query fails, size will be set to -1
		and 0 will be returned.
		*/
		void const * ExecuteBlob( char const * sql, int & size );

	private:
		/** Copy operations are not permitted. */
		Database( Database const & ); // NOT IMPLEMENTED
		Database & operator=( Database const & ); // NOT IMPLEMENTED
		/**
		Simply calls this->Open( this->GetName() ).
		*/
		int Open();
		mutable sqlite3 * m_db; // db handle
		CString m_name; // db name
	};


	/**
	Simplifies the use of transactions in sqlite3. Remember
	that sqlite3 does NOT support nested transactions, so it
	is not legal to have more than one active Transaction object
	at a time.

	When doing lots of inserts, using a Transaction can
	drastically speed up the process (to the order of 10x
	or more improvement).
	*/
	class Transaction
	{
	private:
		// copy operations not implemented
		Transaction & operator=( Transaction const & );
		Transaction( Transaction const & );
		Database &m_con;
		bool m_intrans;
	public:
		/**
		Opens a transaction for the given connection. If
		start==true (the default) then this->Begin() is
		called. This object must outlive con.
		*/
		Transaction(Database &con, bool start=true);

		/** If destructed before Commit() is called,
		Rollback() is called.
		*/
		~Transaction();

		/** Starts a transaction. Returns 0 on success, non-zero on error.
		Return code is that of Database::Execute().
		*/
		int Begin();
		/** Commits a transaction. Returns 0 on success, non-zero on error.
		Return code is that of Database::Execute().
		*/
		int Commit();
		/** Rolls back a transaction with a commit. Returns 0 on success, non-zero on error.
		Return code is that of Database::Execute().
		*/
		int Rollback();

		/**
		Returns true if this->Begin() has been sucessfully run without
		an intervening this->Commit() or this->Rollback().
		*/
		bool IsActive() const;
	};


	class Statement;
	/**
	A type for reading results from a Statement object.

	Objects of this type is not normally created directly,
	but is fetched from a Statement, like so:

	<code>
	Database db( _T("\\path\\to\\my.db") );
	Statement st( db, _T("select * from sqlite_master") );
	Reader r = st.ExecuteReader();
	while( SQLITE_ROW == r.Step() )
	{
	...
	}
	st.Finalize(); // must be call before db closes or db close will fail.
	</code>
	*/
	class Reader
	{
	public:
		/** Usable only as the target of assignment. */
		Reader();
		/**
		When the last Reader associated with a Statement destructs,
		it has the side-effect of calling Reset() on that
		statement. i'm not quite sure why it was designed this way,
		though.
		*/
		~Reader();

		/** rhs and this object point to the same underlying db statement. */
		Reader( Reader const & rhs );

		/** rhs and this object point to the same underlying db statement. */
		Reader & operator=( Reader const & rhs );

		/**
		Takes one step through the dataset.
		On success it returns SQLITE_ROW, SQLITE_DONE
		at the end of the set, and some other value on error.
		*/
		int Step();
		/**
		Equivalent to calling Reset() on the Statement to which
		this object is tied, and returns the same return value.
		*/
		int Reset();

		/**
		Returns the column count for this object's statement,
		or -1 on error. Note that only SELECT statements have
		a column count. INSERT statements have a column count of 0.
		*/
		int GetColCount();

		/**
		If index is a valid column (0-based) then the name of the column
		is returned, else an empty string is returned.
		*/
		CString GetColName( int index );

		/**
		Sets val to the integer value of the field at the given index (0-based).
		If it returns false then an error occurred val is not modified.
		*/
		bool GetInt( int index, int & val );

		/**
		Sets val to the int64_t value of the field at the given index (0-based).
		If it returns false then an error occurred val is not modified.
		*/
		bool GetInt64( int index, int64_t & val );

		/**
		Sets val to the double value of the field at the given index (0-based).
		If it returns false then an error occurred val is not modified.
		*/
		bool GetDouble( int index, double & val );

		/**
		Sets val to the string value of the field at the given index (0-based).
		If it returns false then an error occurred val is not modified.
		*/
		bool GetString( int index, CString & val );

		/**
		If index is a valid column (0-based) then size is set to the size (in bytes)
		of data in the column and a pointer to the data is returned. If index is
		out of range or some other error occurrs, then size is set to -1 and 0 is returned.
		*/
		void const * GetBlob( int index, int & size );

	private:
		friend class Statement;
		Statement * m_cmd;
		/**
		Closes this reader, making it invalid for further use.
		If this reader is the last one to use the underlying Statement
		object then this also calls sqlite3_reset() on that statement handle
		and returns the value of sqlite3_reset(), otherwise it returns
		SQLITE_OK.

		Closing a closed reader is a no-op and causes 0 to be returned.

		Design question: why does this function exist??? What benefit does
		it really provide? Not quite sure.
		*/
		int Close();

		/** Only used by Statement. Pointer may NOT be null and ownership
		is not transfered. This object must outlive st.
		*/
		explicit Reader( Statement * st );
		/**
		Returns true if this reader is opened and index is
		in the range of [0,this->m_cmd->GetColCount()).
		*/
		bool IsValidIndex( int index );
	};

	/**
	Statement encapsulates a single SQL prepared statement.
	*/
	class Statement
	{
	public:
		/**
		Prepares a statement for the given db and sql code.
		Call IsValid() to find out if the preparation worked.
		*/
		Statement( Database & db, CString const & sql );
		/**
		Releases db resources associated with this statement.
		*/
		~Statement();
		/**
		Returns the number of columns in the data set, or -1 on error.
		This will be 0 for INSERT commands and such, and will be
		non-zero for SELECT statements.
		*/
		int GetColCount() const;
		/**
		Releases db-side resources used by this statement.
		After calling this, no other functions in this class
		should be used. Return value is that of sqlite3_finalize(),
		with the exception that calling Finalize() multiple times
		is a no-op, and SQLITE_OK will be returned on on subsequent
		Finalize() calls.

		Note that you must call Finalize() (or let this object go out of
		scope) before your Database goes out of scope (or is closed), or
		else closing of the database will fail due to open statements.
		*/
		int Finalize();
		/**
		Binds NULL to the given index (0-based).
		Return value is that of sqlite3_bind_null().
		*/
		int Bind( int index );
		/**
		Binds data to the given index (0-based).
		Return value is that of sqlite3_bind_int().
		*/
		int Bind( int index, int data );
		/**
		Binds data to the given index (0-based).
		Return value is that of sqlite3_bind_int64().
		*/
		int Bind( int index, int64_t data );
		/**
		Binds data to the given index (0-based).
		Return value is that of sqlite3_bind_double().
		*/
		int Bind( int index, double data );
		/**
		Binds data to the given index (0-based).
		Return value is that of sqlite3_bind_text16().
		*/
		int Bind( int index, CString const & data );
		/**
		Binds data to the given index (0-based).
		Return value is that of sqlite3_bind_text().
		*/
		int Bind( int index, char const * data, int datalen );
		/**
		Binds data to the given index (0-based).
		Return value is that of sqlite3_bind_blob().
		*/
		int Bind( int index, void const * data, int datalen );

		/**
		Creates and returns a Reader object for this object.
		*/
		Reader ExecuteReader();
		/**
		Executes this statement, which is assumed to be a SINGLE
		SQL statement which does not return anything. Return
		value is SQLITE_OK on success, or another value on error.
		*/
		int ExecuteNonQuery();

		/**
		Assumes this statement is of a type which returns a value (e.g. SELECT),
		has at least one column, and that the first column can be returned
		in val.

		Return value is SQLITE_OK on success, or another value on error.
		On error, val is unchanged.
		*/
		int ExecuteInt( int & val );
		/**
		Assumes this statement is of a type which returns a value (e.g. SELECT),
		has at least one column, and that the first column can be returned
		in val.

		Return value is SQLITE_OK on success, or another value on error.
		On error, val is unchanged.
		*/
		int ExecuteInt64( int64_t & val );
		/**
		Assumes this statement is of a type which returns a value (e.g. SELECT),
		has at least one column, and that the first column can be returned
		in val.

		Return value is SQLITE_OK on success, or another value on error.
		On error, val is unchanged.
		*/
		int ExecuteDouble( double & val );
		/**
		Assumes this statement is of a type which returns a value (e.g. SELECT),
		has at least one column, and that the first column can be returned
		in val.

		Return value is SQLITE_OK on success, or another value on error.
		On error, val is unchanged.
		*/
		int ExecuteString( CString & val );
		/**
		Assumes this statement is of a type which returns a value (e.g. SELECT),
		has at least one column, and that the first column is convertable to blob
		data. size is set to the returned data size and the returned pointer points
		to the data. On error, size is set to -1 and 0 is returned.
		*/
		void const * ExecuteBlob( int & size );

		/**
		Calls sqlite3_reset() on the underlying prepared statement
		and returns the value of that function, or SQLITE_ERROR if
		this statement is not valid.
		*/
		int Reset();

		/**
		Returns true if this statement was successfully constructed/prepared, else false.
		*/
		bool IsValid() const;

	private:
		friend class Reader;
		// Copy operations not implement.
		Statement & operator=( Statement const & );
		Statement( Statement const & );
		Database * m_db;
		sqlite3_stmt * m_st;
		unsigned int m_refs; // reference count for Reader class
		int m_colcount; // column count of result set.

	};
} // namespace
